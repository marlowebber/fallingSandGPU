#pragma kernel Shockwave

Texture2D<float4> shockwave_input;
RWTexture2D<float4> shockwave_output	;

[numthreads(8,8,1)]

void Shockwave (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	
	float spring_height_center = shockwave_input[id.xy].r - 0.5;
	float spring_speed_center = shockwave_input[id.xy].g - 0.5;
	float avg_nbr_height = 0.0;
	float nbrs = 0.0;
	
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			float2 nbr = float2(id.x+x,id.y+y);
			float spring_height_here =  shockwave_input[nbr].r - 0.5;
			avg_nbr_height += spring_height_here;
		}
	}
	
	avg_nbr_height = avg_nbr_height/8.0;
	float spring_force_now = (avg_nbr_height - spring_height_center) * 0.5;
	spring_force_now -= spring_height_center * 0.0005;
	spring_speed_center += spring_force_now;
	spring_height_center += spring_speed_center;
	shockwave_output[id.xy] = float4( spring_height_center+0.5 , spring_speed_center+0.5 , 0.0 , 1.0  );	
	if (id.x < 5  || id.x > size - 5 || id.y < 5 || id.y > size- 5){shockwave_output[id.xy] = float4( 0.5,  0.0, 0.0, 1.0  );}
}





#pragma kernel GameOfLife

Texture2D<float4> gol_input;
RWTexture2D<float4> gol_output	;

[numthreads(8,8,1)]

void GameOfLife (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	static const float pi = 3.14159265;
	
	float alive_nbrs = 0.0;
	float alive_here = gol_input[id.xy].r;
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			float2 nbr = float2(id.x + x, id.y + y);
			if (gol_input[nbr].r > 0.5)
			{
				alive_nbrs += 1.0;
			}
		}
	}

	if (alive_here > 0.5)
	{
		if (alive_nbrs >= 2.0 && alive_nbrs <= 3.0)
		{
			; // stay alive
		}
		else
		{
			alive_here = 0.0;
		}
	}
	else
	{
		if (alive_nbrs == 3.0)
		{
			alive_here = 1.0;
		}
	}
	gol_output[id.xy] = float4( alive_here, alive_here, alive_here, 1.0f );
	
}







// https://matthias-research.github.io/pages/tenMinutePhysics/17-fluidSim.pdf


/*



the program needs to modify 3 cells value per index per turn, but can't do this in a single pass due to thread safety.





  initial --- >    cell (i,j) changes made
  		   cell



 
 
 airflow1 adds the contribution to cell n, and airflow2 adds the contribution to n+1 while ensuring symmetrical behavior.













*/


float4 advect_lookup( RWTexture2D<float4> divergence1_input, float2 pos )
{

	const int size = 1024;
	
	
	
	
	
	float groat = 1.0; //abs(divergence1_input[pos].z);
	float take_x = divergence1_input[pos].x * groat ;
	float take_y = divergence1_input[pos].y * groat;
	
	

	 float2 take = float2(take_x, take_y);
	
	
	float4 nbr1 = divergence1_input[pos + float2(0,1)];
	float4 nbr2 = divergence1_input[pos + float2(0,-1)];
	float4 nbr3 = divergence1_input[pos + float2(1,0)];
	float4 nbr4 = divergence1_input[pos + float2(-1,0)];
	take += nbr1.xy * nbr1.z;
	take += nbr2.xy * nbr1.z;
	take += nbr3.xy * nbr1.z;
	take += nbr4.xy * nbr1.z;
	take = take / 5.0;
	
	take *= size;
	
	
	
	
	
	
	float4 pagd = divergence1_input[pos - take];
	/*
	pagd += divergence1_input[take + float2(0,1)];
	pagd += divergence1_input[take + float2(0,-1)];
	pagd += divergence1_input[take + float2(1,0)];
	pagd += divergence1_input[take + float2(-1,0)];
	pagd = pagd / 5.0;
	*/
	return pagd ;
	
	
	// return divergence1_input[take];

}



#pragma kernel Divergence1

RWTexture2D<float4>   divergence1_in;

RWTexture2D<float4>   divergence1_out;

RWTexture2D<float4> divergence1_display;

[numthreads(8,8,1)]




void Divergence1 (uint3 id : SV_DispatchThreadID)
{

	const int size = 1024;
	
	
	
	
	// advection
	
	float4 result = advect_lookup(divergence1_in, id.xy);
	float4 px =	advect_lookup(divergence1_in, float2( id.x+1,id.y ) )  ;
	float4 nx =	advect_lookup(divergence1_in, float2( id.x-1,id.y ) ) ;
	float4 py =	advect_lookup(divergence1_in, float2( id.x,id.y+1 ) ) ;
	float4 ny =	advect_lookup(divergence1_in, float2( id.x,id.y-1 ) )  ;
	
	/*
	float4 result = divergence1_in[ id.xy ];
	
	float4 px =	divergence1_in[ float2( id.x+1,id.y ) ] ;
	float4 nx =	divergence1_in[ float2( id.x-1,id.y ) ] ;
	float4 py =	divergence1_in[ float2( id.x,id.y+1 ) ] ;
	float4 ny =	divergence1_in[ float2( id.x,id.y-1 ) ]  ;
	*/
	
	//  // Rule 2 : Disordered Energy diffuses completely :
	result.b = (nx.b + ny.b + px.b + py.b) / 4.0;

	
  	 // Rule 3 : Order in the disordered Energy creates Order :
  	 result.r += (nx.b - px.b) / 4.0;
  	 result.g += (ny.b - py.b) / 4.0;
			
	// Rule 4 : Disorder in the ordered Energy creates Disorder :
	result.b += ( (nx.r - px.r) + (ny.g - py.g) )  / 4.0;
	
	 
	// mass conservation
    	result.a += (((nx.r*nx.a)-(px.r*px.a))+((ny.g*ny.a)-(py.g*py.a)))/4.0;
    
    	const int boundary = 10;
    	 if(id.x<boundary||id.y<boundary||id.x<boundary||id.y<boundary)
    	{
 	   	result.r = 0.0;
  	  	result.g = 0.0;
  	}
    	
    	
 	result.r *= 0.999;
 	result.g *= 0.999;
 	
 	//result.g -= result.a / 300.0; 
 
    
    divergence1_out[id.xy] = result;
    const float magnif = 20.0;
    divergence1_display [id.xy] = float4(
	
		
		result.r * magnif + 0.5,
		result.g * magnif + 0.5,
		result.b * magnif + 0.5,
		1.0
	);    
}



/*
#pragma kernel Divergence2

RWTexture2D<float4>   workspace;

RWTexture2D<float4> display;

[numthreads(8,8,1)]

void Divergence2 (uint3 id : SV_DispatchThreadID)
{

	const int size = 1024;

	int xid2 = id.x-1;
	int yid2 = id.y-1;
	
	float xval2 = (divergence2_input[float2(xid2, id.y)].b ) ;
	float yval2 = (divergence2_input[float2(id.x, yid2)].a ) ;
	
	
	float4 here = workspace[id.xy];
	
	
float herex = (here.r) + xval2);
float herey = (here.g)+ yval2) ;

	
	workspace [id.xy] = float4(
	
		herex ,
		herey,
		here.z,
		1.0
	); 
	
	
	display [id.xy] = float4(
	
		0.0,
		herey,
		herex, 
		1.0
	);
	  
}

*/



#pragma kernel Advect1

RWTexture2D<float4>   advect1_input;

RWTexture2D<float4> advect1_output	;

[numthreads(8,8,1)]

void Advect1 (uint3 id : SV_DispatchThreadID)
{

	advect1_output[id.xy] = advect_lookup(advect1_input, id.xy);
	
			
}



#pragma kernel Diffuse1

RWTexture2D<float4>   diffuse1_input;

RWTexture2D<float4> diffuse1_output	;

[numthreads(8,8,1)]

void Diffuse1 (uint3 id : SV_DispatchThreadID)
{
	
	const int size = 1024;
	
	float avgx = diffuse1_input[id.xy].r ;
	float avgy = diffuse1_input[id.xy].g ;
	
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			
			
			
			avgx += diffuse1_input[float2(id.x + x, id.y + y)].r ;
			avgy += diffuse1_input[float2(id.x + x, id.y + y)].g ;
		}
	}
	avgx = avgx / 9;
	avgy = avgy / 9;
	diffuse1_output[id.xy] = float4(avgx , avgy , 0.0, 1.0);
			
}





