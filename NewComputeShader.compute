#pragma kernel Shockwave

Texture2D<float4> shockwave_input;
RWTexture2D<float4> shockwave_output	;

[numthreads(8,8,1)]

void Shockwave (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	
	float spring_height_center = shockwave_input[id.xy].r - 0.5;
	float spring_speed_center = shockwave_input[id.xy].g - 0.5;
	float avg_nbr_height = 0.0;
	float nbrs = 0.0;
	
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			float2 nbr = float2(id.x+x,id.y+y);
			float spring_height_here =  shockwave_input[nbr].r - 0.5;
			avg_nbr_height += spring_height_here;
		}
	}
	
	avg_nbr_height = avg_nbr_height/8.0;
	float spring_force_now = (avg_nbr_height - spring_height_center) * 0.5;
	spring_force_now -= spring_height_center * 0.0005;
	spring_speed_center += spring_force_now;
	spring_height_center += spring_speed_center;
	shockwave_output[id.xy] = float4( spring_height_center+0.5 , spring_speed_center+0.5 , 0.0 , 1.0  );	
	if (id.x < 5  || id.x > size - 5 || id.y < 5 || id.y > size- 5){shockwave_output[id.xy] = float4( 0.5,  0.0, 0.0, 1.0  );}
}





#pragma kernel GameOfLife

Texture2D<float4> gol_input;
RWTexture2D<float4> gol_output	;

[numthreads(8,8,1)]

void GameOfLife (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	static const float pi = 3.14159265;
	
	float alive_nbrs = 0.0;
	float alive_here = gol_input[id.xy].r;
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			float2 nbr = float2(id.x + x, id.y + y);
			if (gol_input[nbr].r > 0.5)
			{
				alive_nbrs += 1.0;
			}
		}
	}

	if (alive_here > 0.5)
	{
		if (alive_nbrs >= 2.0 && alive_nbrs <= 3.0)
		{
			; // stay alive
		}
		else
		{
			alive_here = 0.0;
		}
	}
	else
	{
		if (alive_nbrs == 3.0)
		{
			alive_here = 1.0;
		}
	}
	gol_output[id.xy] = float4( alive_here, alive_here, alive_here, 1.0f );
	
}







// https://matthias-research.github.io/pages/tenMinutePhysics/17-fluidSim.pdf


/*



the program needs to modify 3 cells value per index per turn, but can't do this in a single pass due to thread safety.





  initial --- >    cell (i,j) changes made
  		   cell



 
 
 airflow1 adds the contribution to cell n, and airflow2 adds the contribution to n+1 while ensuring symmetrical behavior.













*/

#pragma kernel Divergence1

Texture2D<float4>   divergence1_input;

RWTexture2D<float4> divergence1_output	;

[numthreads(8,8,1)]

void Divergence1 (uint3 id : SV_DispatchThreadID)
{

	// the function writes B as x+1 changes and A as y+1 changes.
	// after the whole texture is finished processing, the changes on B and A channels are recombined. 

	const int size = 1024;
	float flowx1 =	divergence1_input[ float2( id.x,id.y ) ].r - 0.5;
	float flowx2 =	(divergence1_input[ float2( id.x+1,id.y ) ].r - 0.5 );
	float flowy1 =	divergence1_input[ float2( id.x,id.y ) ].g - 0.5;
	float flowy2 =	(divergence1_input[ float2( id.x,id.y+1 ) ].g - 0.5 );
	float inflowx = flowx1 - flowx2;
	float inflowy = flowy1 - flowy2;
	float totalinflow = inflowx + inflowy;
	float adjust = totalinflow / 4;
	
	
	
	
	
	
	
	
	divergence1_output[id.xy]               = float4 ( flowx1 - adjust + 0.5, flowy1 - adjust + 0.5 ,   adjust + 0.5  , adjust+ 0.5);
	
	
	if (id.x < 5  || id.x > size - 5 || id.y < 5 || id.y > size- 5){divergence1_output[id.xy] = float4( 0.5,  0.5, 0.5, 1.0  );}
	
	
}




#pragma kernel Divergence2

Texture2D<float4>   divergence2_input;

RWTexture2D<float4> divergence2_output	;

[numthreads(8,8,1)]

void Divergence2 (uint3 id : SV_DispatchThreadID)
{

	
	divergence2_output [id.xy] = float4(
	
		((divergence2_input[float2(id.x, id.y)].r -0.5)+ (divergence2_input[float2(id.x-1, id.y)].b - 0.5)) + 0.5,
		((divergence2_input[float2(id.x, id.y)].g -0.5)+ (divergence2_input[float2(id.x, id.y-1)].a - 0.5)) + 0.5,
		0.0,
		1.0
	);
}





#pragma kernel Advect1

Texture2D<float4>   advect1_input;

RWTexture2D<float4> advect1_output	;

[numthreads(8,8,1)]

void Advect1 (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	
	/* velx is r and vely is g */
	
	
	
	float flowx1 =	advect1_input[ float2( id.x,id.y ) ].r - 0.5;
	float flowy1 =	advect1_input[ float2( id.x,id.y ) ].g - 0.5;

	const float kt = 50.0;
	flowx1 *= kt;
	flowy1 *= kt;

	float2 take = float2(  id.x + flowx1,  id.y + flowy1 );
	float4 minugs = advect1_input[take];
	
	
	advect1_output[id.xy] = minugs;
	
			
}



#pragma kernel Diffuse1

Texture2D<float4>   diffuse1_input;

RWTexture2D<float4> diffuse1_output	;

[numthreads(8,8,1)]

void Diffuse1 (uint3 id : SV_DispatchThreadID)
{
	const int size = 1024;
	
	/* velx is r and vely is g */
	
	float avgx = diffuse1_input[id.xy].r - 0.5;
	float avgy = diffuse1_input[id.xy].r - 0.5;
	
	for(float y = -1.0; y <= 1.0; y+=1.0)
	{
		for(float x = -1.0; x <= 1.0; x+=1.0)
		{
			if (x == 0.0 && y == 0.0)
			{
				continue;
			}
			avgx += diffuse1_input[float2(id.x + x, id.y + y)].r - 0.5;
			avgy += diffuse1_input[float2(id.x + x, id.y + y)].g - 0.5;
		}
	}
	avgx = avgx / 9;
	avgy = avgy / 9;
	diffuse1_output[id.xy] = float4(avgx + 0.5, avgy + 0.5, 0.0, 1.0);
			
}





